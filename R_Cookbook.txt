*******************************************************************
*******************************************************************
########################CHAPTER 1##################################

###getting help on a function

> help(functionname) ###display the documentation for the function
## you can also do > ?functionname ## and get same result as above
> args(functionname) ###quick reminder of the function arguments
> example(functionname) ###see examples of using the function


> help.search("pattern") ###search R documentation on your computer. "pattern" is a function name or keyword. 
##you can also do ??pattern ##and get the same as above
##if package is not loaded, it may fail to find the pattern or function

###getting help on a package

> help(package="tseries") ###this will display the information and details on the package
> vignette(package="tseries") ###this will display the "vignettes" (tutorial, reference, etc) for the package. if you know name of vignette, then type:
> vignette("vignettename")


*******************************************************************
*******************************************************************
########################CHAPTER 2##################################

> print(objectname) ##lets you print only an object at a time. matrix, list, etc.
> cat ("object1", "object2", "\n") ## prints several objects, need to indicate end of line

###setting and defining variables

> x <- 3 ### setting x to 3 can be done in several different ways. This is ideal over all others.

###listing variables

> ls() ###lists (displays) the names of all objects in workspace
> ls.str() ###displays more information about each variable, other than simply name

> rm(x) ###removes variable x from workspace
> rm(list=ls()) ### removes all variables from workspace (same as clear workspace in menu)

###CREATING A VECTOR
###vectors can contain either numbers, strings, or logical values, but not a mixture

> c(1,1,2,4,5,5,5,8,9,10) ###creates a vector 
> v1 <- c(1,2,3) ##defines object v1 as vector
> c(v1, v2) ##creates a single vector from joining two previously defined vectors
> mode(v1) ##prints the type of vector that is v1; good to know if vectors are compatible before joining them

###BASIC STATS

##functions mean and sd can be used in full dataframes, they are calculated per column.
> mean(dataframeobject) ##this will return as many values as columns (after first column)

###SELECTING VECTOR ELEMENTS	

##if you have a vector as such:

> fib <- c(0,1,1,2,4,8,10)
## in order to print the first element only of the vector, you type:
> fib[1]
>fib[1:5] ##selects elements 1 through 5
> fib[c(1,2,4,6)] ###picks the indicated elements in the vector to create a new one(excluding the others)
> fib[-1] ###prints all elements except the first one
> fib[-(1:3)] ###prints all elements except one through three

###filtering the vectors
> fib < 10 ##this vector is TRUE wherever fib is less than 10. Prints a string of TRUE/FALSE
> fib[fib < 10] ###selects elements from vector that are less than 10. Prints those elements that are TRUE


*******************************************************************
*******************************************************************
########################CHAPTER 3##################################


> history() ##will display most recent command
> history(100) ##will display the 100 most recent commands used
> history(Inf) ##show entire saved history of commands

> search() ##displays list of packages that are currently loaded

> library(packagename) ##and also require(packagename) load packages needed
> detach(package:packagename) ##unloads the specified package. must add package: before packagename for it to work.

####ACCESSING BUILT-IN DATASETS

> data(datasetname, package="packagename") ##loads built-in R dataset
> help(datasetname) ##bring up help page for the dataset
> summary(datasetname) ##gives info on dataset

> data() ##bring up a list of all built-in datasets currently available
> data(package="packagename") ##gives a list of available datasets per loaded package

> source("myScript.R") ##reads and executes an R script
> source("myScript.R", echo=TRUE) ##echoes script lines before they are executed


*******************************************************************
*******************************************************************
########################CHAPTER 4##################################
 
> sink("filename") ##begins writing output to a filename
> sink() ##resume writing output to console instead of file


###the following five lines of code is for writing outputs into different sections to a file by opening a connection (con) to a file and then writing the output repeatedly to the connection
> con <- file("analysisReport.out", "w")
> cat(data, file=con)
> cat(results, file=con)
> cat(conclusion, file=con)
> close(con)

> list.files() ##shows the contents of your current working directory
> list.files(recursive=T) ##shows all the files in current working directory as well as subdirectories. Does not show hidden files.

###TABULAR DATA FILES
> dfrm <- read.table("filename") ##this will return the data frame, with each line containing a record, and within each record there are items separated by a one-character delimiter (comma, tab, space, colon)
> dfrm <- read.table("filename", sep=":") ##if file uses a separator that is not the default, white space
> class(dfrm$column1) ##this will tell you what format (string, factor, etc) is that column
> dfrm <- read.table("filename", stringsAsFactor=FALSE) ##will prevent read.table from interpreting character strings as factors
> dfrm <- read.table("filename", header=TRUE, stringsAsFactor=FALSE) ##allows you to read columns names into data frame matrix

###CSV FILES
###csv files are similar, but they assume that there is a header (compared to tabular that default is no header)
###it also interprets your nonnumerical data as a factor (categorical variable) instead of a string
> tbl <- read.csv("filename", header=FALSE) #if matrix has no header, otherwise it's the default


*******************************************************************
*******************************************************************
########################CHAPTER 5##################################
 
##vectors can be indexed by position
> v[2] ##refers to the second element of vector v
##vectors can be indexed in multiple positions creating a subvector
> v[c(2,3)] ##subvector that consists of second and third elements of vector v

##lists can be indexed by position
> lst[[[2]] ##this refers to the second element of the list
##lists can also be indexed to extract sublists
> lst[c(2,3)]
##list elements can have names and elements can be accessed through the name
> lst[["Moe"]] ##and also:
> lst$Moe ##refer to the element Moe in the list lst

##because a dataframe is both a list and a rectangular data structure, you can use either list operators or matrix notations
> dfrm[i] ##list operators
> dfrm[[i]] ##list operators
> dfrm$name ##list operators
> dfrm[i,j] ##matrix notation
> dfrm[i,] ##matrix notation
> dfrm[,j] ##matrix notation

##adding values and vectors to preexisting vectors
> v <- c(1,2,3) ##create vector v
> v <- c(v,4) ##append single item to vector v
> w <- c(5,6,7,8) ##create vector w
> v <- c(v,w) ##append the entire vector w to vector v, so that you now have 1:8 in vector v

> append(1:10, 99, after=5) ##this adds the number 99 after position 5 in vector 1:10
> append(1:10, 99, after=0) ##this adds the number 99 at position 0, or beginning of sequence 1:10

> cbind(1:3) ##create a column vector of length three
> cbind(1:6) ##create a column vector of length 6
> cbind(1:6, 1:3) ##merges these two column vectors, but uses recycling rule to complete matrix as such:
##matrix:
1	1
2	2	
3	3
4	1
5	2
6	3

> lst[[n]] ##select nth element of list lst
> lst[c(1,2,5)] ##select three elements, returns a sublist
> lts[n] ##select nth LIST --> very different from accessing the single element as above
####you can also access elements by name
> lst[["name"]] ##selects the element called name
> lst$name ##also selects element called name
> lst[c("name1", "name2", name3")] ##returns sublist extracted from lst
> lst["name"] ##will extract a list called "name", not an element!
###to remove an element from a list, select it by position or by name, and then assign NULL to selected element
> lst[["elementname"]] <- NULL ##eliminates that element from the list
###if a list needs to be transformed into a vector, for example if need to perform computations:
> mean(unlist(iq.scores)) ##this will "flatten" the list iq.scores to a vector so that the function "mean" can be performed

###REMOVING LIST ELEMENTS USING A CONDITION
######if you build a logical vector based on the condition you want, then you can use a vector to select list elements to assign NULL to 
> lst[lst < 0] <- NULL ##removes all negative values from the list lst
###if the condition is a function that cannot handel a list, then you need to flatten to a vector
> lst[abs(unlist(lst)) < 1] <- NULL ##eliminates values whose absolute values (function abs) is less than 1
> lst[lapply(lst,abs) < 1] <- NULL ##this also works but uses the lapply function to apply abs function to every element of the list

###BASIC MATRIX OPERATIONS
> t(A) ##matrix transposition of A
> solve(A) ##matrix inverse of A
> A %*% B ##matrix multiplication of A and B
> diag(n) ##an n-by-n diagonal or identity matrix

###ADDITIONAL MATRIX OPERATIONS
#####adding names to a matrix 
> colnames(matrixobjectName) <- c("A","B","C") ##assigns names A, B, and C to matrix columns
> rownames(matrixObjectNAme) <- c("x","Y","Z") ##assigns names X, Y, Z, to matrix rows
#####selecting one row or column from a Matrix
> vec <- mat[1,] ##using normal indexing, you get a simple vector of only first row
> vec <- mat[,3] ##using normal indexing, you get a simple vector of only third column
> row <- mat[1,,drop=FALSE] ##result is a one-row matrix of first row
> col <- mat[,3,drop=FALSE] ##result is a one-column matrix of column three

####INITIALIZING A DATA FRAME
#######if data is captured by several vectors or factors, and it's in column form, then:
> dfrm <- data.frame(v1,v2,v3,v4,f1,f2) ##will generate a matrix with four vectors and two factors
#######if data is captures by a list that contains vectors or factors, and it's in column form, then:
> drfm <- as.data.frame(list.of.vectors) ##will generate a matrix from the list of vectors

####SELECTING DATA FRAME COLUMNS BY POSITION OR NAME
> dfrm[[n]] ##use the list operator to return a single column
> dfrm[n] ##returns a data frame that only contains column "n" 
> dfrm[c(1,2,5)] ##returns a data frame of columns 1,2, and 5
> dfrm[,n] ##returns the nth column (assuming n contains only one value)
> dfrm[,c(1,2,5)] ##returns a data frame built from columns 1,2, and 5
> dfrm[["name]] ##returns the single column "name"
> dfrm$name ##same as above
#######to return one or more columns as a data frame:
> dfrm["name"] ##returns data frame of single column
> dfrm[c("name1","name2","name3")] ##returns data frame with those three selected columns
> dfrm[,"name"] ##returns the named column
> dfrm[,c("name1","name2","name3")] ##returns a data frame of those named columns

####MAKING A SUBSET OF YOUR DATA FRAME
#######for example, you want to select a subset of your data frame pending conditions:
> subset(dfrm, select=c(predictor,response), subset=(response > 0) ##specifiying the dataset first, you want to make a subset of your data
##frame where you only keep the "entries" where the response value is greater than zero, but keeping the specified predictor variable
##associated to the data frame

#####ADDING NEW NAMES TO COLUMNS IN A DATA FRAME
> dfrm <- as.data.frame(lst) ##convert the "list" to a data frame
> colnames(dfrm) <- c("A","B","C") ##add names A B C to the first three columns of data frame

####Excluding a column by name
> subset(dfrm, select = -badboy) ##subset results in data frame of all columns except badboy
####Performing a correlation matrix while excluding a column by name (for example is column is ID, location, etc)
> cor(subset(patient.data, select = -patient.id)) ##generates a correlation matrix of data frame patient.data while excluding the column patient.id
> cor(subset(patient.data, select = c(-patient.id,-dosage)) ##generates corr matrix while excluding two columns specific in vector c

####COMBINING DATA FRAMES
> all.cols <- cbind(dfrm1,dfrm2) ##combines columns of two data frames side by side
> all.rows <- rbind(dfrm1,dfrm2) ##stacks rows of two data frames top to bottom

####SIMPLIFYING ACCESS TO DATA FRAME CONTENTS
######instead of having to type in the data and name info into an equation to calculate z-scores:
> z <- (suburbs$pop - mean(suburbs$pop)) / sd(suburbs$pop) ##calculates z-scores of dataframe "suburbs" for column "pop"
######you can simplify the above expression by using the function "with"
> z <- with(suburbs, (pop - mean(pop) / sd(pop)

########you can also ATTACH a data frame so that the column names become variables you can easily access
> attach(suburbs) ##makes all column names available as variables for dataset "suburbs"
####WARNING: attach can be very tricky when editing the dataframe, so it's better to avoid


*******************************************************************
*******************************************************************
########################CHAPTER 6##################################











